pub use futures_core::future::BoxFuture;

use std::net::SocketAddr;

use futures_util::FutureExt;
use tokio::{net::UnixListener, sync::oneshot::Receiver};
use tokio_stream::wrappers::UnixListenerStream;
use tonic::transport::server::TcpIncoming;

use crate::fs::cleanup;
use crate::server::ListenerConfig;

use super::TonicResult;

/// Wraps a Tonic RPC service in a manageable component
///
/// The only real required method is `to_router`.
pub trait TonicService: Send + Sync + 'static {
    /// Returns the Tonic Router generated by instantiating a tonic server builder and adding
    /// your services.
    fn to_router(&self) -> tonic::transport::server::Router;

    /// Creates the actual listener (TCP or UDS) and generates the router future
    fn listen(
        &self,
        listener_config: &ListenerConfig,
        shutdown: Receiver<()>,
    ) -> BoxFuture<'static, TonicResult> {
        match listener_config {
            ListenerConfig::Tcp { port, addr } => {
                let listen_address: SocketAddr = format!("{}:{}", addr, port).parse().unwrap();
                let listener = TcpIncoming::new(listen_address, true, None).unwrap();
                Box::pin(
                    self.to_router()
                        .serve_with_incoming_shutdown(listener, shutdown.map(drop)),
                )
            }
            ListenerConfig::Uds { socket } => {
                cleanup(socket).unwrap();
                let uds = UnixListener::bind(socket).unwrap();
                let listener = UnixListenerStream::new(uds);
                Box::pin(
                    self.to_router()
                        .serve_with_incoming_shutdown(listener, shutdown.map(drop)),
                )
            }
        }
    }
}
